name: Terraform CD
run-name: "CD ‚Äî ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_branch || github.ref_name }} (${{ github.event_name }})"

on:
  workflow_run:
    workflows: ["Terraform CI"]
    branches: [main, developer]
    types: [completed]

  # Deploy emergencial sem CI ‚Äî requer justificativa
  workflow_dispatch:
    inputs:
      force_apply:
        description: 'For√ßar apply mesmo sem mudan√ßas no plan?'
        required: false
        type: boolean
        default: false
      reason:
        description: 'Justificativa para deploy manual (obrigat√≥rio em prod)'
        required: false
        type: string
        default: ''

  # Drift detection ‚Äî roda plan di√°rio sem apply para detectar mudan√ßas manuais
  schedule:
    - cron: '0 6 * * 1-5'   # Seg-Sex √†s 06:00 UTC

# Garante que apenas 1 deploy por ambiente rode simultaneamente.
# cancel-in-progress: false ‚Äî cancelar apply pode corromper o state.
concurrency:
  group: cd-${{ github.ref_name }}
  cancel-in-progress: false

permissions:
  contents: read
  actions: read    # Necess√°rio para ler status do workflow_run

env:
  TERRAFORM_VERSION: '1.10.5'
  AWS_REGION: 'us-east-1'

# =============================================================================
# Job 1: Resolve Environment
# =============================================================================
jobs:
  resolve-env:
    name: Resolve Environment
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      env_name: ${{ steps.resolve.outputs.env_name }}
      tfvars_path: ${{ steps.resolve.outputs.tfvars_path }}
      backend_path: ${{ steps.resolve.outputs.backend_path }}
      is_drift_check: ${{ steps.resolve.outputs.is_drift_check }}

    steps:
      - name: Abort if CI failed
        if: >-
          github.event_name == 'workflow_run' &&
          github.event.workflow_run.conclusion != 'success'
        run: |
          echo "::error::CI terminou com '${{ github.event.workflow_run.conclusion }}' ‚Äî CD abortado."
          exit 1

      - name: Map branch ‚Üí environment
        id: resolve
        run: |
          IS_DRIFT="false"

          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            BRANCH="${{ github.event.workflow_run.head_branch }}"
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            BRANCH="${{ github.ref_name }}"
            IS_DRIFT="true"
          else
            BRANCH="${{ github.ref_name }}"
          fi

          case "$BRANCH" in
            main)      ENV="prod" ;;
            developer) ENV="dev"  ;;
            *)
              echo "::error::Branch n√£o mapeada: $BRANCH"
              exit 1
              ;;
          esac

          {
            echo "env_name=$ENV"
            echo "tfvars_path=envs/${ENV}/terraform.tfvars"
            echo "backend_path=envs/${ENV}/backend.hcl"
            echo "is_drift_check=$IS_DRIFT"
          } >> "$GITHUB_OUTPUT"

          echo "Branch '$BRANCH' ‚Üí ambiente '$ENV' (drift_check=$IS_DRIFT)"

      # Valida inputs de workflow_dispatch para prod
      - name: Validate manual deploy inputs
        if: >-
          github.event_name == 'workflow_dispatch' &&
          steps.resolve.outputs.env_name == 'prod' &&
          inputs.reason == ''
        run: |
          echo "::error::Deploy manual em prod requer justificativa no campo 'reason'."
          exit 1

# =============================================================================
# Job 2: Terraform Plan
# =============================================================================
  plan:
    name: Plan (${{ needs.resolve-env.outputs.env_name }})
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: resolve-env
    outputs:
      has_changes: ${{ steps.plan.outputs.has_changes }}
      plan_summary: ${{ steps.stats.outputs.summary }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Para workflow_run, garante que o checkout √© do commit que disparou o CI
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        run: |
          IDENTITY=$(aws sts get-caller-identity --output json)
          echo "AWS Identity: $(echo "$IDENTITY" | jq -r '.Arn')"
          echo "Account: $(echo "$IDENTITY" | jq -r '.Account')"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false   # Desabilita wrapper para PIPESTATUS funcionar corretamente

      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            **/.terraform/providers
          key: tf-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}
          restore-keys: tf-providers-${{ runner.os }}-

      - name: Configure Terraform plugin cache
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraformrc

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="${{ needs.resolve-env.outputs.backend_path }}" \
            -reconfigure \
            -input=false \
            -no-color

      - name: Terraform Plan
        id: plan
        run: |
          set +e

          terraform plan \
            -var-file="${{ needs.resolve-env.outputs.tfvars_path }}" \
            -out=tfplan \
            -detailed-exitcode \
            -input=false \
            -no-color 2>&1 | tee plan_output.txt

          EXIT_CODE=${PIPESTATUS[0]}

          case $EXIT_CODE in
            0)
              echo "‚ÑπÔ∏è  Sem mudan√ßas em '${{ needs.resolve-env.outputs.env_name }}'."
              echo "has_changes=false" >> "$GITHUB_OUTPUT"
              ;;
            1)
              echo "::error::Terraform plan falhou."
              echo "has_changes=false" >> "$GITHUB_OUTPUT"
              exit 1
              ;;
            2)
              echo "‚úÖ Plan gerado com mudan√ßas ‚Äî aguardando aprova√ß√£o."
              echo "has_changes=true" >> "$GITHUB_OUTPUT"
              ;;
          esac

      - name: Extract plan statistics
        id: stats
        if: always()
        run: |
          if [[ ! -f plan_output.txt ]]; then
            echo "summary=Plan falhou antes de gerar output" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          ADDED=$(grep -oP '\d+(?= to add)'       plan_output.txt | tail -1 || echo 0)
          CHANGED=$(grep -oP '\d+(?= to change)'  plan_output.txt | tail -1 || echo 0)
          DESTROYED=$(grep -oP '\d+(?= to destroy)' plan_output.txt | tail -1 || echo 0)

          echo "summary=+${ADDED:-0} ~${CHANGED:-0} -${DESTROYED:-0}" >> "$GITHUB_OUTPUT"

          # Alerta expl√≠cito se h√° destrui√ß√µes (especialmente em prod)
          if [[ "${DESTROYED:-0}" -gt 0 && "${{ needs.resolve-env.outputs.env_name }}" == "prod" ]]; then
            echo "::warning::‚ö†Ô∏è ATEN√á√ÉO: Plan inclui ${DESTROYED} destrui√ß√µes em PRODU√á√ÉO!"
          fi

      - name: Generate plan summary
        if: always()
        run: |
          ENV="${{ needs.resolve-env.outputs.env_name }}"
          {
            echo "### üìã Terraform Plan ‚Äî \`${ENV}\`"
            echo ""

            if [[ -f plan_output.txt ]]; then
              ADDED=$(grep -oP '\d+(?= to add)'       plan_output.txt | tail -1 || echo 0)
              CHANGED=$(grep -oP '\d+(?= to change)'  plan_output.txt | tail -1 || echo 0)
              DESTROYED=$(grep -oP '\d+(?= to destroy)' plan_output.txt | tail -1 || echo 0)

              echo "| A√ß√£o | Quantidade |"
              echo "|------|-----------|"
              echo "| ‚ûï Add     | **${ADDED:-0}** |"
              echo "| üîÑ Change  | **${CHANGED:-0}** |"
              echo "| üî¥ Destroy | **${DESTROYED:-0}** |"
              echo ""
              echo "<details><summary>Ver plano completo</summary>"
              echo ""
              echo '```hcl'
              cat plan_output.txt
              echo '```'
              echo "</details>"
            else
              echo "‚ùå **Plan falhou** ‚Äî nenhum output gerado."
            fi

            echo ""
            echo "_Branch: \`${{ github.ref_name }}\` ¬∑ Commit: \`${{ github.sha }}\`_"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload plan artifact
        if: steps.plan.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ needs.resolve-env.outputs.env_name }}-${{ github.sha }}
          path: |
            tfplan
            plan_output.txt
          retention-days: 1

# =============================================================================
# Job 3: Drift Detection Alert (schedule only ‚Äî n√£o faz apply)
# =============================================================================
  drift-alert:
    name: Drift Alert (${{ needs.resolve-env.outputs.env_name }})
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [resolve-env, plan]
    if: >-
      needs.resolve-env.outputs.is_drift_check == 'true' &&
      needs.plan.outputs.has_changes == 'true'

    steps:
      - name: Alert drift detected
        run: |
          ENV="${{ needs.resolve-env.outputs.env_name }}"
          SUMMARY="${{ needs.plan.outputs.plan_summary }}"

          echo "::warning::üîÄ DRIFT detectado em '${ENV}': ${SUMMARY}"
          echo "Mudan√ßas manuais foram feitas fora do Terraform."
          echo "Investigue e corrija via PR ou terraform import."

          # ‚îÄ‚îÄ Webhook de notifica√ß√£o (Slack/Teams/Discord) ‚îÄ‚îÄ
          # Descomente e configure DRIFT_WEBHOOK_URL nos secrets:
          #
          # if [[ -n "${{ secrets.DRIFT_WEBHOOK_URL }}" ]]; then
          #   curl -sf -X POST "${{ secrets.DRIFT_WEBHOOK_URL }}" \
          #     -H 'Content-Type: application/json' \
          #     -d "{
          #       \"text\": \"üîÄ Drift detectado em *${ENV}*: ${SUMMARY}\",
          #       \"environment\": \"${ENV}\",
          #       \"run_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
          #     }" || echo "::warning::Falha ao enviar notifica√ß√£o de drift"
          # fi

      - name: Drift summary
        run: |
          {
            echo "### üîÄ Drift Detection ‚Äî \`${{ needs.resolve-env.outputs.env_name }}\`"
            echo ""
            echo "**Drift detectado!** Mudan√ßas: \`${{ needs.plan.outputs.plan_summary }}\`"
            echo ""
            echo "A√ß√£o recomendada: investigar altera√ß√µes manuais e reconciliar via PR."
          } >> "$GITHUB_STEP_SUMMARY"

# =============================================================================
# Job 4: Terraform Apply (bloqueado por Environment Gate)
# =============================================================================
  apply:
    name: Apply (${{ needs.resolve-env.outputs.env_name }})
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: [resolve-env, plan]

    # N√£o aplica em drift check (schedule) ‚Äî apenas detecta e alerta
    if: >-
      needs.resolve-env.outputs.is_drift_check != 'true' &&
      (
        needs.plan.outputs.has_changes == 'true' ||
        fromJSON(inputs.force_apply || 'false') == true
      )

    # Environment Gate ‚Äî requer aprova√ß√£o manual no GitHub UI
    # Configure: Settings ‚Üí Environments ‚Üí deploy-dev / deploy-prod
    environment: deploy-${{ needs.resolve-env.outputs.env_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Configure AWS Credentials
        # Reconfigura credenciais ‚Äî session token AWS Academy pode ter expirado
        # desde o plan. Atualize os secrets antes de aprovar se necess√°rio.
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        run: |
          IDENTITY=$(aws sts get-caller-identity --output json)
          echo "AWS Identity: $(echo "$IDENTITY" | jq -r '.Arn')"
          echo "Account: $(echo "$IDENTITY" | jq -r '.Account')"

          # Valida√ß√£o extra: garante que estamos na conta correta para o ambiente
          ACCOUNT=$(echo "$IDENTITY" | jq -r '.Account')
          echo "account_id=$ACCOUNT" >> "$GITHUB_OUTPUT"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            **/.terraform/providers
          key: tf-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}
          restore-keys: tf-providers-${{ runner.os }}-

      - name: Configure Terraform plugin cache
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraformrc

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="${{ needs.resolve-env.outputs.backend_path }}" \
            -reconfigure \
            -input=false \
            -no-color

      - name: Download plan artifact
        uses: actions/download-artifact@v4
        with:
          name: tfplan-${{ needs.resolve-env.outputs.env_name }}-${{ github.sha }}

      # ‚îÄ‚îÄ State backup antes do apply ‚îÄ‚îÄ
      # Salva snapshot do state ANTES de aplicar mudan√ßas.
      # Em caso de falha catastr√≥fica, permite rollback manual.
      - name: Backup current state
        id: backup
        run: |
          BACKUP_FILE="state-backup-${{ needs.resolve-env.outputs.env_name }}-$(date -u '+%Y%m%d-%H%M%S').json"
          terraform state pull > "$BACKUP_FILE" 2>/dev/null || true

          if [[ -s "$BACKUP_FILE" ]]; then
            echo "‚úÖ State backup salvo: $BACKUP_FILE ($(wc -c < "$BACKUP_FILE") bytes)"
            echo "backup_file=$BACKUP_FILE" >> "$GITHUB_OUTPUT"
          else
            echo "‚ö†Ô∏è State vazio ou inacess√≠vel ‚Äî primeiro deploy?"
            echo "backup_file=" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload state backup
        if: steps.backup.outputs.backup_file != ''
        uses: actions/upload-artifact@v4
        with:
          name: state-backup-${{ needs.resolve-env.outputs.env_name }}-${{ github.sha }}
          path: ${{ steps.backup.outputs.backup_file }}
          retention-days: 90

      - name: Terraform Apply
        id: apply
        run: |
          ENV="${{ needs.resolve-env.outputs.env_name }}"
          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')

          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "  üöÄ TERRAFORM APPLY"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "  Ambiente  : $ENV"
          echo "  Aprovado  : ${{ github.actor }}"
          echo "  Commit    : ${{ github.sha }}"
          echo "  Timestamp : $TIMESTAMP"
          [[ -n "${{ inputs.reason }}" ]] && echo "  Raz√£o     : ${{ inputs.reason }}"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

          set +e
          terraform apply \
            -auto-approve \
            -input=false \
            -no-color \
            tfplan 2>&1 | tee apply_output.txt

          EXIT_CODE=${PIPESTATUS[0]}
          echo "exitcode=$EXIT_CODE" >> "$GITHUB_OUTPUT"

          if [[ "$EXIT_CODE" != "0" ]]; then
            echo "::error::Terraform apply falhou com exit code $EXIT_CODE"
            exit 1
          fi

      - name: Apply summary
        if: always()
        run: |
          EXIT="${{ steps.apply.outputs.exitcode }}"
          STATUS=$([[ "$EXIT" == "0" ]] && echo "‚úÖ Sucesso" || echo "‚ùå Falhou (exit=$EXIT)")

          {
            echo "### üöÄ Terraform Apply ‚Äî \`${{ needs.resolve-env.outputs.env_name }}\`"
            echo ""
            echo "**Status: $STATUS**"
            echo ""
            echo "| Campo | Valor |"
            echo "|-------|-------|"
            echo "| **Ambiente**     | \`${{ needs.resolve-env.outputs.env_name }}\` |"
            echo "| **Aprovado por** | \`${{ github.actor }}\` |"
            echo "| **Commit**       | \`${{ github.sha }}\` |"
            echo "| **Timestamp**    | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |"
            [[ -n "${{ inputs.reason }}" ]] && echo "| **Raz√£o**        | ${{ inputs.reason }} |"
            echo ""

            if [[ -f apply_output.txt ]]; then
              echo "<details><summary>Ver output completo</summary>"
              echo ""
              echo '```'
              cat apply_output.txt
              echo '```'
              echo "</details>"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload apply output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: apply-output-${{ needs.resolve-env.outputs.env_name }}-${{ github.sha }}
          path: apply_output.txt
          retention-days: 90   # 90 dias para auditoria (n√£o 30)

      - name: Terraform Outputs
        if: steps.apply.outputs.exitcode == '0'
        run: |
          {
            echo "### üì§ Terraform Outputs"
            echo '```json'
            terraform output -json -no-color 2>/dev/null || echo '{"_note": "Sem outputs definidos"}'
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

# =============================================================================
# Job 5: Post-Apply Verification
# =============================================================================
  verify:
    name: Verify (${{ needs.resolve-env.outputs.env_name }})
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [resolve-env, apply]
    if: always() && needs.apply.result == 'success'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Configure Terraform plugin cache
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraformrc

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="${{ needs.resolve-env.outputs.backend_path }}" \
            -reconfigure \
            -input=false \
            -no-color

      # Roda plan p√≥s-apply para confirmar que o state est√° limpo
      # Se detectar drift imediato, algo deu errado no apply
      - name: Post-apply drift check
        id: verify_plan
        run: |
          set +e
          terraform plan \
            -var-file="${{ needs.resolve-env.outputs.tfvars_path }}" \
            -detailed-exitcode \
            -input=false \
            -no-color 2>&1 | tee verify_output.txt

          EXIT_CODE=${PIPESTATUS[0]}

          case $EXIT_CODE in
            0)
              echo "‚úÖ State limpo ‚Äî sem drift p√≥s-apply."
              echo "clean=true" >> "$GITHUB_OUTPUT"
              ;;
            2)
              echo "::warning::‚ö†Ô∏è Drift detectado imediatamente ap√≥s apply!"
              echo "Poss√≠veis causas: eventual consistency da AWS, recursos com lifecycle ignore_changes, ou providers com bugs."
              echo "clean=false" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "::error::Verifica√ß√£o falhou."
              echo "clean=error" >> "$GITHUB_OUTPUT"
              exit 1
              ;;
          esac

      # ‚îÄ‚îÄ Smoke tests customiz√°veis ‚îÄ‚îÄ
      # Adicione verifica√ß√µes espec√≠ficas da sua infra aqui.
      # Exemplos: health check de ALB, DNS resolution, API ping
      - name: Smoke tests
        if: hashFiles('scripts/smoke-test.sh') != ''
        run: |
          chmod +x scripts/smoke-test.sh
          ./scripts/smoke-test.sh "${{ needs.resolve-env.outputs.env_name }}"

      - name: Verification summary
        if: always()
        run: |
          CLEAN="${{ steps.verify_plan.outputs.clean }}"
          STATUS=$([[ "$CLEAN" == "true" ]] && echo "‚úÖ Limpo" || echo "‚ö†Ô∏è Drift detectado")

          {
            echo "### üîé Post-Apply Verification ‚Äî \`${{ needs.resolve-env.outputs.env_name }}\`"
            echo ""
            echo "**Drift check:** $STATUS"
            echo ""

            if [[ "$CLEAN" != "true" && -f verify_output.txt ]]; then
              echo "<details><summary>Ver diferen√ßas</summary>"
              echo ""
              echo '```hcl'
              cat verify_output.txt
              echo '```'
              echo "</details>"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

# =============================================================================
# Job 6: Notification (falhas)
# =============================================================================
  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [resolve-env, plan, apply]
    if: always() && (needs.plan.result == 'failure' || needs.apply.result == 'failure')

    steps:
      - name: Send failure notification
        run: |
          ENV="${{ needs.resolve-env.outputs.env_name }}"
          FAILED_JOB=$([[ "${{ needs.plan.result }}" == "failure" ]] && echo "plan" || echo "apply")
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "::error::Deploy falhou no job '$FAILED_JOB' para ambiente '$ENV'"

          # ‚îÄ‚îÄ Slack webhook ‚îÄ‚îÄ
          # Configure SLACK_WEBHOOK_URL nos secrets do reposit√≥rio
          #
          # if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
          #   curl -sf -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
          #     -H 'Content-Type: application/json' \
          #     -d "{
          #       \"blocks\": [
          #         {
          #           \"type\": \"section\",
          #           \"text\": {
          #             \"type\": \"mrkdwn\",
          #             \"text\": \"üö® *Deploy falhou* em \`${ENV}\`\n*Job:* ${FAILED_JOB}\n*Commit:* \`${{ github.sha }}\`\n*Actor:* ${{ github.actor }}\n<${RUN_URL}|Ver logs>\"
          #           }
          #         }
          #       ]
          #     }" || echo "::warning::Falha ao enviar notifica√ß√£o Slack"
          # fi

      - name: Failure summary
        run: |
          {
            echo "### üö® Deploy Failed ‚Äî \`${{ needs.resolve-env.outputs.env_name }}\`"
            echo ""
            echo "| Job | Resultado |"
            echo "|-----|-----------|"
            echo "| Plan  | \`${{ needs.plan.result }}\` |"
            echo "| Apply | \`${{ needs.apply.result }}\` |"
            echo ""
            echo "**A√ß√£o necess√°ria:** verifique os logs e corrija antes de re-deploiar."
            echo ""
            echo "Se o apply falhou parcialmente:"
            echo "1. Verifique o state com \`terraform state list\`"
            echo "2. Use o state backup (artefato \`state-backup-*\`) se necess√°rio"
            echo "3. Nunca fa√ßa \`terraform destroy\` em prod sem valida√ß√£o manual"
          } >> "$GITHUB_STEP_SUMMARY"
